---
layout: post
title: "Go_実践"
date: 2023-10-23
category: Go
excerpt: ""
---
# 実践編

## リポジトリの構成
- cmd/server
  - GoのAPIサーバーの立ち上げや、DIなどの処理をここにかこう
- handler
  - アプリケーション層、リクエスト、レスポンスの処理を記述する
- domain
  - userとgroupのモデリング箇所(今回はstruct定義くらいになっちゃう)
  - repositoryのIFの定義
- usecase
  - ビジネスロジックを記述する
- infrastructure
  - 永続化の実装を書く(今回はMySQL)
- schema
  - 今回はテーブル定義が記述されている

## モジュール関連
- modファイルの作成
```bash
go mod init <モジュール名>
```

## クエリパラメータの取得
- `http.Request.URL.Query().Get("パラメータ名")`で取得できる
- 複数のクエリパラメータを取得するときは`http.Request.URL.Query()`でmap配列が取得できる

```Go
func hoge (w http.ResponseWriter, r *http.Request) {
    // 1つだけ取得
    user_id := r.URL.Query().Get("user_id")
    // 複数取得(queryのvalueは配列になっているので注意)
    params := r.URL.Query()
    user_id= params["user_id"][0]
```

##　複数レコードを取得する
### 基本方針
- Query、QueryContextを使ってSQL文を発行することで複数レコードを取得できる
- QueryContextによって得られたrowsをfor文で回すことで個々の要素を取り出すことができる
- 個々の要素を配列にappendすることでarray型として返却できる

```Go
    // makeで初期化しないと、レスポンスが空の時nullが返却されてしまう
		groups := make([]GroupOutput,0)
		user_id := r.URL.Query().Get("user_id")
		rows, err := db.QueryContext(context.Background(), "SELECT id, name FROM `groups` WHERE user_id = ?", user_id)
		// 取得できなかったときは空配列を返す
		if err != nil {
			j, _ := json.Marshal(&groups)
			w.WriteHeader(http.StatusOK)
			w.Write(j)
			return
		}
		defer rows.Close()
		// rows.Next()はbooleanを返す。次の要素があるときはTrueになる。
		// つまり、rowsの要素が全て取り出されるまで無限ループする
		for rows.Next() {
			var group GroupOutput
			if err := rows.Scan(&group.ID, &group.Name); err != nil {
				return
			}
			groups = append(groups, group)
		}
		j, err := json.Marshal(&groups)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusOK)
		w.Write(j)
```
### 注意点
- レスポンスの配列はmakeで初期化すること
  - ❌：`var groups []GroupOutput`
  - makeで初期化しないと、レスポンスが空の時nullが返却されてしまう

- モジュールのインストール・削除
```bash
go mod tidy
```
go.modファイルが存在するディレクトリ以下にある.goファイルを自動で検知してくれる

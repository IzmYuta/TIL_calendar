---
layout: post
title: "Go_Test"
date: 2023-10-21
category: Go
excerpt: ""
---
# Test

## 1. 基本
- Goのテストはgo testでUTやBenchmarkなどさまざまなテストを実行できる
- ファイルのサフィックスに_testがついているものをテスト対象とする
- テストファイルはビルド対象にならない
- 実行例：`go test tdd_test.go main.go -v`

### 1.1 テストの種類

**Test：**
- プレフィックスにTestがついている
- ユニットテストなど

**Benchmark**
- プレフィックスにBenchmarkがついている
- パフォーマンスの比較

**Fuzz**
- プレフィックスにFuzzがついている
- 初期で与えられた値からランダムな値を生成して入力値からバグを発見する

**Example**
- プレフィックスにExampleがついている
- 出力結果のテストやGoDocにサンプルとして載せることができる

### 1.2 assert
- Goのtesting packageにはLog、Skip、ヘルパーなどしか存在しない。assertは標準で搭載されていない(3rdパッケージには一応ある)。
  - Assertは便利だがエラーメッセージが自動で出力されるため、レポート内容が適当になる
  - エラーレポートは何が起きたかを書くことが重要なためしっかりと自分で書く
  - 覚えることを増やすことより丁寧に書き、今後のデバッグの際に役立つようにしよう


### 1.3 Table Driven Test
- GoではテストをTable Driven Testで書くことが推奨されている
- 公式wikiにも書き方などが存在する
- テストケースの入出力を1つのstructにまとめ、すべてのテストケースをforを用いて実行する

ポイント：
- 新しいテストケースの追加が容易
- テーブルをみることで入出力から期待する内容を理解できる
- structとmapでの実行順序が変わる可能性があるため注意する
- Goに限られたテスト手法ではない

```go
tests := []struct {
 name string
 args args
 want int
 wantErr bool
}{
  // 下が1つのテストケース
  {
  name: “success”,
  args: args {
  i: 1,
  j: 2,
  },
  want: 3,
  wantErr: false,
 },
}
```

### 1.4 testing.Parallel
- Goにはtesting.Parallelという関数がある
- testing.Parallelを使うことで同一パッケージ内のテストを逐次ではなく並行に実行できる

注意点：
- サブテストをParallelで並行にする際は値をコピーする(goroutineの起動よりもforを使う方が早い)
- Parallelなサブテストはトップレベルのテストが実行されたあとに処理される
- Table Driven testでカバーできることが多いのでサブテストの採用は慎重に(1Test1Assertion)

(参考：https://qiita.com/marnie_ms4/items/d5233045a084cebeea14)

### 1.5 raceの検出
- -raceオプションを有効にすることでデータの競合を検出することができる
- 実行例：`go test -race race_test.go main.go -v`
- raceするテストではracememを生成したgoroutineとTestRaceのgoroutineどちらからも操作されている
  - データ競合を避けるためには排他制御をしてあげる必要がある
 
### 1.6 便利メソッド
- Cleanup
  - Cleanupを呼び出しているテスト関数は一番最後に呼ばれる
  - Parallelを使うとトップレベルが先に終了するため絶対に最後にしたい処理はCleanupを使う
- Setenv
  - Cleanupを用いてそのテスト関数だけで使える環境変数をセットできる
- Tempdir
  - Cleanupを用いてそのテスト関数だけで使える一時ディレクトリを作成することができる
- Helper
  - ヘルパー関数などを読んだときに呼び出し先の行数でエラーなどが出力されるようになる
  - テストのレポート情報をより正確に伝えることができる
  
